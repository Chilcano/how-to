"""
This is a simplified Python demonstration of Fully Homomorphic Encryption (FHE)
using the Pyfhel library. It attempts to illustrate a more "realistic" scenario
where the key pair is generated by the user, the encrypted data is processed by
the server (without accessing the private key), and finally, the result is
decrypted by the user.

DISCLAIMER:
- This is an educational example, not production-ready code.
- In a real environment, the user would generate and securely store the key pair,
  possibly leveraging hardware security modules (HSMs) or enclaves.
- The server-side environment should be a trusted execution environment (TEE)
  or "enclave" to ensure integrity and provide cryptographic attestations.
- Always review cryptographic parameters for proper security levels in
  real-world scenarios.
"""

from Pyfhel import Pyfhel


# -----------------------------
# PART A: User Key Generation
# -----------------------------
def generate_user_keypair():
    """
    Generates the user's FHE context and key pair (public and private keys).
    Returns a Pyfhel object that internally holds both keys.

    In a realistic scenario, the user would keep the private key secret and would
    only share the public key (or relevant relinearization keys, Galois keys, etc.)
    with the server.
    """
    user_HE = Pyfhel()
    # Context generation with some default parameters
    # NOTE: For production, carefully select security parameters (poly_modulus, coeff_modulus, etc.)
    user_HE.contextGen(p=65537)  # Using a prime p for BFV or BGV schemes
    user_HE.keyGen()             # Generates both public and private keys internally
    return user_HE


# -----------------------------
# PART B: User Encrypts Data
# -----------------------------
def encrypt_user_data(user_HE, value):
    """
    Encrypt a single integer 'value' using the user's public key (stored internally in user_HE).

    user_HE: The Pyfhel object that contains the public key.
    value:   The integer value to encrypt.

    Returns an encrypted ciphertext (PyCtxt).
    """
    encrypted_value = user_HE.encryptInt(value)
    return encrypted_value


# ---------------------------------
# PART C: Server-Side Computations
# ---------------------------------
def compute_on_encrypted_data(server_HE, encrypted_salary):
    """
    Simulates the server receiving the encrypted data and performing
    homomorphic operations on it.

    server_HE:      A Pyfhel object containing the SAME context and the public key
                    (in a real scenario, the server should NOT have access to the
                    private key).
    encrypted_salary: The ciphertext representing the user's salary.

    Returns an encrypted ciphertext with the new result.
    """
    # Let's simulate the server performing: (salary + 500) * 2
    # The server does NOT know 'salary' because it's encrypted.

    # For homomorphic addition and multiplication, we need to encrypt the constants as well.
    encrypted_constant_500 = server_HE.encryptInt(500)
    encrypted_constant_2   = server_HE.encryptInt(2)

    # Homomorphic addition
    encrypted_sum = encrypted_salary + encrypted_constant_500
    # Homomorphic multiplication
    encrypted_result = encrypted_sum * encrypted_constant_2

    return encrypted_result


# -----------------------------
# PART D: User Decrypts Result
# -----------------------------
def decrypt_user_data(user_HE, encrypted_result):
    """
    Decrypt the final ciphertext using the user's private key
    (contained in the user_HE object).

    user_HE:         The Pyfhel object that contains the private key.
    encrypted_result: The ciphertext to be decrypted.

    Returns the plaintext integer result.
    """
    plaintext_value = user_HE.decryptInt(encrypted_result)
    return plaintext_value


# -----------------------------
# MAIN DEMO WORKFLOW
# -----------------------------
def main():
    print("=== Fully Homomorphic Encryption (FHE) Demo ===")

    # -----------------------------------------------
    # Step 1: User generates keys (public and private)
    # -----------------------------------------------
    print("\n[Step 1] Generating user key pair...")
    user_HE = generate_user_keypair()

    # Simulate that the user_HE object has the private key, which MUST remain secret.
    # The user could share only the public key (and context parameters) with the server.

    # -------------------------------------------
    # Step 2: User encrypts salary with public key
    # -------------------------------------------
    user_salary = 1000
    print(f"\n[Step 2] User encrypts their salary ({user_salary}) using their public key...")
    encrypted_salary = encrypt_user_data(user_HE, user_salary)

    # For demonstration, we assume that user_HE can also provide a "server_HE" object
    # to the server, but in a real scenario, we'd only give the "context" and "public key"
    # to the server, NOT the private key. Here we keep it simple:
    server_HE = user_HE  # In practice, you would have a separate Pyfhel instance that doesn't have the secret key

    # -------------------------------------------------------
    # Step 3: Server performs computations on encrypted data
    # -------------------------------------------------------
    print("\n[Step 3] Server receives encrypted salary and performs homomorphic operations...")
    encrypted_result = compute_on_encrypted_data(server_HE, encrypted_salary)
    print("Server does not know the actual salary value, only ciphertext objects.")

    # ------------------------------------------------
    # Step 4: Server returns the encrypted result back
    # ------------------------------------------------
    print("\n[Step 4] Server sends the encrypted result back to the user...")

    # -------------------------------------------------------
    # Step 5: User decrypts the final result using private key
    # -------------------------------------------------------
    print("\n[Step 5] User decrypts the returned ciphertext with their private key.")
    final_value = decrypt_user_data(user_HE, encrypted_result)
    print(f"The final value after (salary + 500) * 2 = {final_value}\n")

    print("=== Demo completed successfully ===")


if __name__ == "__main__":
    main()
